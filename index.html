<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Quoridor</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <script type="module" src="js/square.js"></script>
    <script type="module" src="js/board.js"></script>
    <script type="module" src="js/pawn.js"></script>
    <script type="module" src="js/player.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="module">

/*
  This is a JavaScript web app for the board game Quoridor. It makes use of the Phaser 3
  game development framework.

  Written by Bradley Post
*/

import Board from './js/board.js';
import Pawn from './js/pawn.js';
import Square from './js/square.js';
import Player from './js/player.js';

var config = {
    width: 630,
    height: 630,
    type: Phaser.AUTO,
    parent: 'phaser-example',
    scene: {
    	preload: preload,
        create: create,
        update: update
    }
};

// Declaring global variables

var game = new Phaser.Game(config);
var wall;
var rect;
var rectangles;
var graphics;
var a = 0;
var pawn1;
var pawn2;
var turn = 1;
var wallon = 0;

// Loading assets
function preload()
{
	this.load.image('square', 'assets/board_square.png');
	this.load.image('pawn', 'assets/pawn.png');
	this.load.image('wall', 'assets/wall.png');
}

function create ()
{
    // Initialize mouse input, and turn of right click menu
  	var pointer = this.input.activePointer;
  	this.input.mouse.disableContextMenu();
    
    // Initialize the game board
   	var board = new Board({scene: this});
   	console.log(board);
    
    //Initialize pawns. Turn player 2's pawn red
    var pawn1 = new Pawn({scene: this, x: 315, y: 35, board: board});
    var pawn2 = new Pawn({scene: this, x: 315, y:595, board: board});
    pawn2.tint = 0xaa0000;

    /*
	player1 = new Player({board: board, pawn: pawn1, wall_count: 10, cpu: false});
	player2 = new Player({board: board, pawn: pawn2, wall_count: 10, cpu: false});
    */

    // Create a local variable for the current scene to pass into the event handler below
    var _this = this;

    // Create an event handler for mouse input 
    this.input.on('pointerdown', function (pointer) {
        // Change wall display state on right click
        if (pointer.rightButtonDown()){
        	if(wallon === 0)
        	{
        		wallon = 1;
        	} else if (wallon === 1) {
        		wallon = 2;
        	} else if (wallon === 2) {
        		wallon = 0;
        	} else {
        		console.log('Theres a problem with wallon');
        	}
        } // Move pawn if not in wall mode
        else if (wallon === 0)
        {
        	if(turn === 1)
        	{
        		if(pawn1.move(pointer.worldX, pointer.worldY))
        		{
        			turn = 0;
        		}
        	} 
        	else if (turn === 0)
        	{
        		if(pawn2.move(pointer.worldX, pointer.worldY))
        		{
        			turn = 1;
        		}
        	}
        } 
        else
        {
        	var wall_pos = check_wall_placement(pointer.worldX, pointer.worldY);
        	if(!(wall_pos == null))
        	{
        		console.log('wall x: '+wall_pos[0]+'\nwall y: '+wall_pos[1]);
        		var new_wall = _this.add.sprite(wall_pos[1], wall_pos[0], 'wall');
        		if(wallon == 2)
        		{
        			new_wall.angle = 90;
        		}
        	}
        }
    });
    wall = this.add.sprite(0, 0, 'wall');
}

function update ()
{
	// Initialize mouse input
    var pointer = this.input.activePointer;
	// Change the display of the wall piece based on the wallon value
	if (wallon == 0)
	{
		wall.setActive(false).setVisible(false);
	}
	else if(wallon == 1)
	{
		wall.setActive(true).setVisible(true);
		wall.angle = 0;
		wall.setX(pointer.worldX);
		wall.setY(pointer.worldY);
	} 
	else if (wallon == 2)
	{
		wall.setActive(true).setVisible(true);
		wall.angle = 90;
		wall.setX(pointer.worldX);
		wall.setY(pointer.worldY);
	}
}
// Move the pawn when a valid space is clicked on the players given turn
function move_pawn(x, y, point, wallon) {
	if(!point && wallon == 0){
		if(turn1 === 1){
			// Can't move on to a space if the other pawn is there
			if(!(Math.abs(pawn2.x - x) < 70 && Math.abs(pawn2.y - y) < 70)){
				// Can only move forward back left right one space
				if(Math.abs(pawn1.x - x) <=70 && Math.abs(pawn1.y - y) <= 70 && Math.abs(pawn1.x - x)+Math.abs(pawn1.y - y) <= 70){
					pawn1.setX(x);
					pawn1.setY(y);
					turn1 = 0;
				}
			}
			
		}
		else
		{	// Can't move on to a space if the other pawn is there
			if(!(Math.abs(pawn1.x - x) < 70 && Math.abs(pawn1.y - y) < 70)){
				// Can only move forward back left right one space
				if(Math.abs(pawn2.x - x) <=70 && Math.abs(pawn2.y - y) <= 70 && Math.abs(pawn2.x - x)+Math.abs(pawn2.y - y) <= 70){
					pawn2.setX(x);
					pawn2.setY(y);
					turn1 = 1;
				}
			}
		}
	}
}
// Print out the array of the wall placement
function print_wall_arr() {
	var s ="";
	for(var x = 0; x < wall_arr.length; x++)
	{
		
		console.log(wall_arr[x]);
	}
}
// Check to see if the wall can be placed in the place the player clicked. If yes
// call add_wall to place the wall
function check_wall_placement (old_x, old_y) {
	//TODO: Make sure to create the right placement conditions
	var coords = convert_pos_to_wall_arr(old_x, old_y);
	y = coords[0];
	x = coords[1];

	if(wallon == 1)
	{
		if(wall_arr[x][y] != 2 && !(wall_arr[x+1][y] == 2 || wall_arr[x-1][y] == 2))
		{
			
			return add_wall(x,y);
		}
	}
	else if (wallon == 2)
	{
		if(wall_arr[x][y] != 2 && !(wall_arr[x][y+1] == 2 || wall_arr[x][y-1] == 2))
		{
			console.log('made it 2');
			return add_wall(x,y);
		}
	}
}
// Convert mouse pointer coordinates on screen to array indices for the wall array
function convert_pos_to_wall_arr(x, y) {
	new_x = Math.round(x/70);
	new_y = Math.round(y/70);
	return [new_x, new_y];
}
// Convert wall array indices to coordinates on the board
function convert_wall_arr_to_pos(x,y) {
	new_x = x*70;
	new_y = y*70;
	return [new_x, new_y];
}
// Set wall array values to reflect new pieces
// Print updated array to console
function add_wall(x, y) {
	// TODO: Make sure the walls are put in the right place in the array
	if (wallon == 1)
	{
		wall_arr[x][y] = 2;
		wall_arr[x+1][y] = 1;
		wall_arr[x-1][y] = 1;
	} else if (wallon == 2)
	{
		wall_arr[x][y] = 2;
		wall_arr[x][y+1] = 1;
		wall_arr[x][y-1] = 1;
	}
	print_wall_arr();
	return convert_wall_arr_to_pos(x, y);

}

</script>

</body>
</html>